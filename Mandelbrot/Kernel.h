#pragma once

const char* kernel_source =
//"int palette(double pos, double size, int colour) {\n" //pos is between 0 and 1, colour is 0, 1 or 2 for red green or blue
//"   double data[][4] = {\n" //{position, red, green, blue}
//"       {size * 0, 32, 107, 203},\n"
//"       {size * (double)1 / 15, 237, 255, 255},\n"
//"       {size * (double)2 / 15, 255, 170, 0},\n"
//"       {size * (double)3 / 15, 0, 2, 0},\n"
//"       {size * (double)4 / 15, 255, 0, 0},\n"
//"       {size * (double)5 / 15, 0, 255, 0},\n"
//"       {size * (double)6 / 15, 0, 0, 255},\n"
//"       {size * (double)7 / 15, 255, 255, 0},\n"
//"       {size * (double)8 / 15, 255, 0, 255},\n"
//"       {size * (double)9 / 15, 0, 255, 255},\n"
//"       {size * (double)10 / 15, 255, 128, 0},\n"
//"       {size * (double)11 / 15, 128, 255, 0},\n"
//"       {size * (double)12 / 15, 0, 255, 128},\n"
//"       {size * (double)13 / 15, 128, 0, 255},\n"
//"       {size * (double)14 / 15, 255, 0, 128},\n"
//"       {size * 1, 75, 0, 130}\n"
//"   };\n"
//"   int dataSize = sizeof(data) / sizeof(data[0]);\n"
//"   for (int i = 0; i < dataSize - 1; i++) {\n"
//"       if (pos > data[i][0] && pos <= data[i + 1][0]) {\n"
//"           if(colour == 0){return (int)(data[i][1] + (pos - data[i][0]) * (data[i + 1][1] - data[i][1]) * (1 / (data[i + 1][0] - data[i][0])));}\n"
//"           else if(colour == 1){return (int)(data[i][2] + (pos - data[i][0]) * (data[i + 1][2] - data[i][2]) * (1 / (data[i + 1][0] - data[i][0])));}\n"
//"           else if(colour == 2){return (int)(data[i][3] + (pos - data[i][0]) * (data[i + 1][3] - data[i][3]) * (1 / (data[i + 1][0] - data[i][0])));}\n"
//"       }\n"
//"   }\n"
//"   if (colour == 0) { return 32; }\n"
//"   else if (colour == 1) { return 107; }\n"
//"   else if (colour == 2) { return 203; }\n"
//"   return 0;\n"
//"}\n"
"int palette(double pos, double rateOfChange, int colour) {\n" //pos is between 0 and 1
"	if (colour == 0) { return (int)round(127.5 * sin(rateOfChange * 2 * M_PI * pos + 1) + 127.5); }\n"
"	if (colour == 1) { return (int)round(127.5 * sin(rateOfChange * 2 * M_PI * pos + (2.0 / 3.0) * M_PI + 1) + 127.5); }\n"
"	if (colour == 2) { return (int)round(127.5 * sin(rateOfChange * 2 * M_PI * pos + (4.0 / 3.0) * M_PI + 1) + 127.5); }\n"
//"	return { (int)round(127.5 * sin(2 * M_PI * pos) + 127.5), (int)round(127.5 * sin(2 * M_PI * pos + (2.0 / 3.0) * M_PI) + 127.5), (int)round(127.5 * sin(2 * M_PI * pos + (4.0 / 3.0) * M_PI) + 127.5) };\n"
"}\n"
"__kernel void mandelbrot_kernel(__global int* pixelArr, int screenWidth, int screenHeight, double zoom, double position_x, double position_y, int maxIterations, __global const int* workQueue, __global int* globalIndex) {\n"
"   int i = get_global_id(0);\n"
"   int totalPixels = screenWidth*screenHeight;\n"
"   int idx = atomic_inc(globalIndex);\n"
"   double temp;\n"
"   double past[2] = { 0,0 };\n"
"   double temp2;\n"
"   double temp3;\n"

"   while (idx < totalPixels) {\n"
"   int pixelIndex = workQueue[idx];\n"
"   int x = pixelIndex % screenWidth;\n"
"   int y = pixelIndex / screenHeight;\n"
"   int iteration = 0;\n"
"   double z[2] = { 0,0 };\n"
"   double aspectRatio = (double)screenWidth/screenHeight;\n"
"   double c[2] = { ((double)x / screenWidth - 0.5) * zoom * aspectRatio + position_x, ((double)y / screenWidth - 0.5) * zoom + position_y};\n"
//stops when abs(z)>=8 (that is, when pixel coordinates are not on mandlebrot set)
"   while (z[0] * z[0] + z[1] * z[1] < 64 && ++iteration < maxIterations >> 1) {\n"
//z = (z^2 + c)^2 + c where z and c are complex numbers to estimate z = z^2 + c (because we want to remove loops in low level code)
"       past[0] = z[0];\n"
"       past[1] = z[1];\n"
"       temp2 = z[0] * z[0] - z[1] * z[1] + c[0];\n"
"       temp3 = 2 * z[0] * z[1] + c[1];\n"
"       temp = 2 * temp2 * temp3 + c[1];\n"
"       z[0] = temp2 * temp2 - temp3 * temp3 + c[0];\n"
"       z[1] = temp;\n"
"   }\n"
"   z[0] = past[0];\n"
"   z[1] = past[1];\n"
"   iteration = iteration * 2;\n"
"   while (z[0] * z[0] + z[1] * z[1] < 64 && ++iteration < maxIterations) {\n"
//        //z = z^2 + c
"       temp = 2 * z[0] * z[1] + c[1];\n"
"       z[0] = z[0] * z[0] - z[1] * z[1] + c[0];\n"
"       z[1] = temp;\n"
"   }\n"
"   double rationalIteration = iteration + 2 - log(log(z[0] * z[0] + z[1] * z[1])) / log((double)2);\n"
//"   double decimalPart = fmod(rationalIteration, 1);\n"
//"   double colour1[] = {\n"
//"       palette((int)rationalIteration % 128, 128, 0),\n"
//"       palette((int)rationalIteration % 128, 128, 1),\n"
//"       palette((int)rationalIteration % 128, 128, 2) };\n"
//"   double colour2[] = {\n"
//"       palette((int)ceil(rationalIteration) % 128, 128, 0),\n"
//"       palette((int)ceil(rationalIteration) % 128, 128, 1),\n"
//"       palette((int)ceil(rationalIteration) % 128, 128, 2) };\n"
//"   int colour[] = {\n" //linear interpolation
//"       (int)(colour1[0] * (1 - decimalPart) + colour2[0] * decimalPart),\n"
//"       (int)(colour1[1] * (1 - decimalPart) + colour2[1] * decimalPart),\n"
//"       (int)(colour1[2] * (1 - decimalPart) + colour2[2] * decimalPart) };\n"
"   pixelArr[pixelIndex] = palette((double)rationalIteration, 0.01, 0);\n" //red
"   pixelArr[totalPixels + pixelIndex] = palette((double)rationalIteration, 0.01, 1);\n" //green
"   pixelArr[totalPixels * 2 + pixelIndex] = palette((double)rationalIteration, 0.01, 2);\n" //blue
//"   pixelArr[totalPixels * 2 + pixelIndex] = colour[2];\n" //blue
"   idx = atomic_inc(globalIndex);\n"
"   }\n"
//"   pixelArr[i] = (int)((double)iteration*0.5 + 1 - log(log(z[0] * z[0] + z[1] * z[1])) / log((double)2));\n" //red
//"   pixelArr[res*res+i] = (int)((double)iteration*1 + 1 - log(log(z[0] * z[0] + z[1] * z[1])) / log((double)2));\n" //green
//"   pixelArr[res*res*2+i] = (int)((double)iteration*1.5 + 1 - log(log(z[0] * z[0] + z[1] * z[1])) / log((double)2));\n" //blue
"}\n";